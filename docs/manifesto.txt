Утилита manifesto
=================

Утилита предназначена для парсинга исходного кода модуля, выделения из него требуемой для манифеста информации и формирования включаемого файла с этой информацией в формате, пригодном для влючения в исходный код и дальнейшей обработки.

Исходный код утилиты находится в папке moduleBox/manifesto и собирается командой:
make all

Результирующий бинарный файл должен быть перемещён в удоное место, находящееся в путях поиска и дожен запускаться из командной строки без указания абсолютного пути.



Описание модуля 
===============

Для успешного сбора информации из исходного кода модуля для добавления её в манифест требуется соблюдать формат объявлений.
В одном исходном файле может быть описан более чем один модуль.
Для описания нижеследующего элемента используются многострочные комментарии "/* */", однострочные комментарии "//" игнорируются.

Объявление модуля
-----------------
Модуль обрабатывает свою конфигурацию в функции с именем "configure_<имя модуля>", комментарий выше описывает назначение модуля:

/*
    Модуль управляет RGB-лентой
*/
void configure_pwmRGB(PMOSFETCONFIG c, int slot_num)
{
    stdcommand_init(&c->cmds, slot_num);
    ...

В этом примере описан модуль "pwmRGB" с описанием "Модуль управляет RGB-лентой". В случае если в одном исходном файле несколько модулей, эта функция повторяется для каждого модуля. В этой функции происходит объявление/обработка переменных, команд и отчётов.  Для каждого модуля будет описан свой набор переменных, команд и отчётов в рамках соответствующей им функции.


Объявление переменных
---------------------

Переменные определяются по вызову и параметрам функции "get_option_<тип переменной>_val()". Параметры функции зависят от типа переменной. Комментарий выше вызова функции описывает назначение переменной.

/* Величина приращения значения свечения
 */
c->increment = get_option_int_val(slot_num, "increment", "", 255, 1, 4096);

В данном примере описана переменная "increment" типа "int", с диапазоном от 1 до 4096 и значением по умолчанию 255.

/* Коэфициент фильтрации */
c->k = get_option_float_val(slot_num, "filterK", 1);

Переменная "filterK" типа "float", значение по умолчанию 1.

/* Определяет топик для MQTT сообщений */
c->custom_topic = get_option_string_val(slot_num, "topic");

Переменная "topic" типа "string" 

/* Инверсия значений
*/
c->inverse = get_option_flag_val(slot_num, "inverse");

Переменная "inverse" типа flag, может принимать значения "yes", "no", "true", "false", 0, 1.

/* Начальный цвет
*/
if (get_option_color_val(&c->targetRGB, slot_num, "RGBcolor", "0 0 255") != ESP_OK)

Переменная "RGBcolor" типа "color", задаётся тремя десятичными значениями для основных цветов (красный, зелёный, синий).

/* Задаёт режим анимации */
if ((c->ledMode = get_option_enum_val(slot_num, "ledMode", "default", "flash", "glitch", "swiper", "rainbow", "run", NULL)) < 0)

Переменная "ledMode" типа "enum" может быть равна только предопределённым значением. Первое значение является значением по умолчанию.


Объявление команд
-----------------

Команды объявляются вызовом функции регистрации команды. Есть два типа команд: простые команды и команды типа "enum". У обоих функций первые три параметра - обязательные, первый - это указатель на управляющую структуру (объект), второй - пользовательский целочисленный идентификатор команды и третий - текстовое ключевое слово команды. Для первого типа команд допустимо передавать нулевой указатель на ключевое слово, в этом случае простое значение без ключевого слова с указанным типом будет обрабатываться как эта зарегистрированная команда с её идентификатором.

Простая команда объявляется вызовом функции stdcommand_register, второй обязательный параметр

/* Числовое значение.
   задаёт текущее состояние светодиода (вкл/выкл)
 */
stdcommand_register(&c->cmds, MYCMD_default, NULL, PARAMT_int);

Команда сработает в случае прихода простого значения типа int.

/* Установить новое значение приращения
 */
stdcommand_register(&c->cmds, MYCMD_setIncrement, "setIncrement", PARAMT_int);

Команда с ключевым словом "setIncrement" и параметром типа int.

/* Установить новый целевой цвет. 
*/
stdcommand_register(&c->cmds, MYCMD_setRGB, "setRGB", PARAMT_int, PARAMT_int, PARAMT_int);

Команда с ключевым словом "setRGB" и тремя параметрами типа int.

Команда типа "enum" требует наличия ключевого слова и параметра, соответсвующего заданному списку значений.

/* Установить новый режим анимации цветов
*/
stdcommand_register_enum(&c->cmds, MYCMD_setMode, "setMode", "default", "flash", "glitch", "swiper", "rainbow", "run");

Команда с ключевым словом "setMode" требует одного из перечисленных далее значений.


Объявление отчетов
------------------

Объявление отчетов происходит через регистрацию отчетов с помощью функции stdreport_register. Первое значение - предопределённый тип значения, передаваемого в отчёте. Типы могу быть следующие:

RPTT_string - строка,
RPTT_int - числовое значение,
RPTT_float - значение с плавающей точкой,
RPTT_ratio - соотношение.

Отчет описывается сходным образом с остальными типами.


/* Возвращает текущее значение канала ввиде числа с плавающей точкой, выражающее отношение к заданной шкале
 */
ch->ratioReport = stdreport_register(RPTT_ratio, slot_num, "unit", "", (int)ch->MIN_VAL, (int)ch->MAX_VAL);


Функция получения данных манифеста
----------------------------------

Каждый модуль или набор модулей, объедененных одним исходным файлом содержит функцию получения данных манифеста. Функция начинается с ключевых слов "get_manifest_" и завершается именем исходного файла, модуль "pwmRGB" находится в файле 3n_mosfet.c:

const char * get_manifest_3n_mosfet()
{
	return manifesto;
}

До этой функции должен быть включен сгенерированный файл. Лучшее место, обычно - среди остальных включаемых файлов:

#include <generated_files/gen_3n_mosfet.h>




Добавление файла модуля в построение
====================================

Для добавления информации манифеста в модуль требуется препроцессинг исходного кода. Производится это внешней утилитой "manifesto" по правилам добавленным в CMakeLists.txt. Файл с правилами должен выглядеть следующим образом:

---------- 8< ---------------------
file(GLOB_RECURSE MODULE_FILES "ИМЯ_ФАЙЛА_МОДУЛЯ.c"  )


if(NOT CMAKE_BUILD_EARLY_EXPANSION)
include(${CMAKE_HOME_DIRECTORY}/CMakeManifest.txt)
endif()


idf_component_register(SRCS
                        "другие исходинки 1.c"
                        "другие исходинки 2.c"
                        
                        ${MODULE_FILES}

			"другие исходинки 3.c"

                        ${GENERATED_FILES}

                    INCLUDE_DIRS "другие каталоги включения " ${CMAKE_CURRENT_BINARY_DIR}
                    REQUIRES "разные модули"
)
---------- 8< ---------------------

Принципиальные моменты:
- имя исходного файла модуля/модулей должно быть задано в переменной MODULE_FILES
- должен быть включен файл CMakeManifext.txt указанным выше образом
- файлы модулей должны быть добавлены в комиляцию в idf_component_register, лучше через значение перменной MODULE_FILES 
- в idf_component_register должны быть добавлены GENERATED_FILES, это включаемые файлы, которые будут сгенерированы утилитой manifesto
- в INCLUDE_DIRS должен быть указан CMAKE_CURRENT_BINARY_DIR, это место где будут сгенерированы включаемые файлы






